/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#ifndef PLUGINPROCESSOR_H_INCLUDED
#define PLUGINPROCESSOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"


//==============================================================================
/**
*/
class TestPlugin1AudioProcessor  : public AudioProcessor
{
public:
    //==============================================================================
    TestPlugin1AudioProcessor();
    ~TestPlugin1AudioProcessor();


    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    void processBlock (AudioSampleBuffer&, MidiBuffer&) override;

    //==============================================================================
    AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const String getName() const override;

    int getNumParameters() override;
    float getParameter (int index) override;
    void setParameter (int index, float newValue) override;

    const String getParameterName (int index) override;
    const String getParameterText (int index) override;

    const String getInputChannelName (int channelIndex) const override;
    const String getOutputChannelName (int channelIndex) const override;
    bool isInputChannelStereoPair (int index) const override;
    bool isOutputChannelStereoPair (int index) const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool silenceInProducesSilenceOut() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const String getProgramName (int index) override;
    void changeProgramName (int index, const String& newName) override;

    //==============================================================================
    void getStateInformation (MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

	/* OUT OF ORDER! KEEP GOING!
	void setLowEndFilterOffset(int harmonic);		//3 for tierce, 5 for 5th harmonic etc...
	void setLowEndFilterOffset(float hz);			//offset with hertz
	float getLowEndFilterOffste(bool isHarmonic);	//getting the offset in Hz or harmonic
	*/

	//============= GUI FUNCTIONS HERE ================
	void TestPlugin1AudioProcessor::setAttack(int newAttack);
	int TestPlugin1AudioProcessor::getAttack();

	enum
	{
		order = 12,
		fft_size = 1 << order, //1 << order
		stackMax = 50	//FIFO stack of moving avarage for fundamental frequency
						//updating the filter on 1/(dtFFTdata*stackMax) secundum interval
	};

	float max1 = 0; float max1p;
	float max2 = 0; float max2p;
	float max3 = 0; float max3p;
	float lowEnd = 0;

	float	freqStack[stackMax];
	float AVGF = 0; //public average fundamental frequency

	void TestPlugin1AudioProcessor::makeFFTData();

	float offsetOfLowEndFilter = 0;

	IIRFilter lowEndFilterLeft;
	IIRFilter lowEndFilterRight;

	IIRFilter fifthLeft;
	IIRFilter fifthRight;

	void smoothSetFilters();
	float FFTPeaks[3];

	int fifoindex;
	float fifo[fft_size];
	float fft_data[2 * fft_size];
	float offset;

	//GUI input parameters
	int attack = 5;
	float bandWidth = 0.1;
	float peakGain = 1;

	//monitoring cv
	int cv1;
	int cv2;
	int cv3;


private:
    //==============================================================================
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TestPlugin1AudioProcessor)

	juce::FFT fft;
	float avg_sample[fft_size];
	bool fftReady = false;
	//const float* channelData;
	float fifoMA[stackMax];
	
	float	freqMA = 0; //frequency moving avarage
	
	IIRCoefficients lowEndFilterCoefficientsLeft;
	IIRCoefficients lowEndFilterCoefficientsRight;

	IIRCoefficients fifthLeftCoefficients;
	IIRCoefficients fifthRightCoefficients;
	
	void TestPlugin1AudioProcessor::pushFifoMA(float element);
	float TestPlugin1AudioProcessor::GetAvgFifoMA();

};


#endif  // PLUGINPROCESSOR_H_INCLUDED
