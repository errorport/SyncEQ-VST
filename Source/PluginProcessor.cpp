/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
TestPlugin1AudioProcessor::TestPlugin1AudioProcessor()
	:	fft(order, false),
		lowEndFilterLeft(),
		lowEndFilterRight(),
		lowEndFilterCoefficientsLeft(),
		lowEndFilterCoefficientsRight(),
		fifthLeft(),
		fifthRight(),
		fifthLeftCoefficients(),
		fifthRightCoefficients()
{
}

TestPlugin1AudioProcessor::~TestPlugin1AudioProcessor()
{
}

//==============================================================================
const String TestPlugin1AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int TestPlugin1AudioProcessor::getNumParameters()
{
    return 0;
}

float TestPlugin1AudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void TestPlugin1AudioProcessor::setParameter (int index, float newValue)
{
}

const String TestPlugin1AudioProcessor::getParameterName (int index)
{
    return String();
}

const String TestPlugin1AudioProcessor::getParameterText (int index)
{
    return String();
}

const String TestPlugin1AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String TestPlugin1AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool TestPlugin1AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool TestPlugin1AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool TestPlugin1AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool TestPlugin1AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool TestPlugin1AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double TestPlugin1AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int TestPlugin1AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int TestPlugin1AudioProcessor::getCurrentProgram()
{
    return 0;
}

void TestPlugin1AudioProcessor::setCurrentProgram (int index)
{
}

const String TestPlugin1AudioProcessor::getProgramName (int index)
{
    return String();
}

void TestPlugin1AudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void TestPlugin1AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..

	//lowEndFilterLeft.reset();
	//lowEndFilterRight.reset();

	lowEndFilterLeft.setCoefficients(
		lowEndFilterCoefficientsLeft.makeHighPass((double)getSampleRate(), 0)
		);
	lowEndFilterRight.setCoefficients(
		lowEndFilterCoefficientsRight.makeHighPass((double)getSampleRate(), 0)
		);
	offset = getSampleRate() / fft_size;

}

void TestPlugin1AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

/*
float getLowEndFilterOffset()
{
	return offsetOfLowEndFilter;
}

void setLowEndFilterOffset(int harmonic)
{
	offsetOfLowEndFilter *= ((harmonic-1)/harmonic);
}
*/
void TestPlugin1AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages) //noexcept
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...

	// *****************************SYNCEQ BLOCK*************************

	//1 making an avarage mono signal from the both input channels:
	//2 filling up the window for the FFT:
	//3 reset the low-end filter coefficients:
	
	//max1p is the normalized frequency (Hz) position of the first peak
	//max2p : second peak, max3p : third peak

	//flush avg_sample
	zeromem(avg_sample, sizeof(avg_sample));

	for (int j = 0; j < buffer.getNumSamples(); j++)
	{
		cv1 = j;
		avg_sample[j] = 0;
		//get az average mix of channels
		//avg_sample going to be the this mixture, that can be used for processing
		for (int channel = 0; channel < getNumInputChannels(); ++channel)
		{
			float* channelData = buffer.getWritePointer(channel);
			
			avg_sample[j] += channelData[j];

			if (channel == getNumInputChannels() - 1)
			{
				avg_sample[j] = avg_sample[j] / getNumInputChannels();
			}

			//buffer.copyFrom(channel, 0, channelData, buffer.getNumSamples());

			// ..do something to the data...
		}

		if (fifoindex >= fft_size) //&& fftReady==false
		{
			//zeromem(fft_data, sizeof(fft_data));
			memcpy(fft_data, fifo, sizeof(fifo));
			fftReady = true;
			fifoindex = 0;
		}
		else //&& fftReady==false
		{
			fifo[fifoindex] = avg_sample[j];
			fifoindex++;
		}

	}

	//4 modulating
	
		float* channelDataLeft = buffer.getWritePointer(0);
		float* channelDataRight = buffer.getWritePointer(1);
		//safe processiong
		lowEndFilterLeft.processSamples(channelDataLeft, buffer.getNumSamples()); 
		lowEndFilterRight.processSamples(channelDataRight, buffer.getNumSamples());

		fifthLeft.processSamples(channelDataLeft, buffer.getNumSamples());
		fifthRight.processSamples(channelDataRight, buffer.getNumSamples());
		//unsafe but faster processing
		//float output = lowEndFilter.processSingleSampleRaw(*channelData);

		//copy the filtered samples to the output channels

		buffer.copyFrom(0, 0, channelDataLeft, buffer.getNumSamples());
		buffer.copyFrom(1, 0, channelDataRight, buffer.getNumSamples());
	
	
	//EOF ***** SYNCEQ BLOCK *****

	/*
	// stereo to mono. avg_sample[] includes the avarage of the two input channels
	buffer.copyFrom(0, 0, avg_sample, buffer.getNumSamples());
	buffer.copyFrom(1, 0, avg_sample, buffer.getNumSamples());
	*/
}

void TestPlugin1AudioProcessor::makeFFTData()
{
	if (fftReady==true)
	{
		//performing fft processing on fft_data
		fft.performFrequencyOnlyForwardTransform(fft_data);
		//now it is a frequency domain signal, that is equal to F{avg_sample} function
		//Range<float> maxLevel = FloatVectorOperations::findMinAndMax(fft_data, fft_size / 2);

		max1 = 0.0f;
		max2 = 0.0f;
		max3 = 0.0f;

		int i_peakd = 0;

		//first 3 components of highest peaks
		for (i_peakd = 1; i_peakd < fft_size; i_peakd++)
		{
			cv2 = i_peakd;
			if (fft_data[i_peakd] > max1)
			{
				max1 = fft_data[i_peakd];
				max1p = i_peakd * offset;
			}
		}
		
		for (i_peakd = 0; i_peakd < fft_size; i_peakd++)
		{
			if (fft_data[i_peakd] > max2 && fft_data[i_peakd] < max1)
			{
				max2 = fft_data[i_peakd];
				max2p = i_peakd * offset;
			}
		}
		for (i_peakd = 0; i_peakd < fft_size; i_peakd++)
		{
			if (fft_data[i_peakd] > max3 && fft_data[i_peakd] < max2)
			{
				max3 = fft_data[i_peakd];
				max3p = i_peakd * offset;
			}
		}

		//getting the lowest one

		FFTPeaks[0] = max1p;
		FFTPeaks[1] = max2p;
		FFTPeaks[2] = max3p;

		std::sort(FFTPeaks, FFTPeaks + 3);
		lowEnd = FFTPeaks[0];
		if (lowEnd == 0)
		{
			lowEnd = offset;
		}
		//pushing lowEnd
		pushFifoMA(lowEnd);
		fftReady = false;
	}
}

//push an element into FifoMA
//1. pull out the last one &
//2. moving down every elements
//3. pushing the new element into the first place
//4. returns the average of the array
void TestPlugin1AudioProcessor::pushFifoMA(float element)
{
	double sumMA = element;
	for (int k = 0; k < attack - 1; k++)
	{
		fifoMA[k] = fifoMA[k + 1];
		sumMA += fifoMA[k];
	}
	fifoMA[attack-1] = element;
	AVGF = sumMA / attack;
}

//out of order
float TestPlugin1AudioProcessor::GetAvgFifoMA()
{
	float sumMA = 0;
	for (int fifoma_k = 0; fifoma_k < sizeof(fifoMA); fifoma_k++)
	{
		sumMA += fifoMA[fifoma_k];
	}
	return sumMA / sizeof(fifoMA);
}

void TestPlugin1AudioProcessor::smoothSetFilters()
{
	//float AVGF = GetAvgFifoMA();
	lowEndFilterLeft.setCoefficients(
		lowEndFilterCoefficientsLeft.makeHighPass((double)getSampleRate(), AVGF)
		);
	lowEndFilterRight.setCoefficients(
		lowEndFilterCoefficientsRight.makeHighPass((double)getSampleRate(), AVGF)
		);
	fifthLeft.setCoefficients(
		fifthLeftCoefficients.makePeakFilter((double)getSampleRate(), AVGF*(2 / 3), bandWidth, peakGain)
		);
	fifthRight.setCoefficients(
		fifthRightCoefficients.makePeakFilter((double)getSampleRate(), AVGF*(2 / 3), bandWidth, peakGain)
		);
}

//==============================================================================
bool TestPlugin1AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* TestPlugin1AudioProcessor::createEditor()
{
    return new PluginEditor(*this);
}

//==============================================================================
void TestPlugin1AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void TestPlugin1AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new TestPlugin1AudioProcessor();
}

//====================== GUI FUNCTIONS HERE ================
void TestPlugin1AudioProcessor::setAttack(int newAttack)
{
	attack = newAttack;
}

int TestPlugin1AudioProcessor::getAttack()
{
	return attack;
}
